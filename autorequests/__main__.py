import argparse
import json
from pathlib import Path
from typing import List, Optional, Dict, Generator

from . import regexp
from .classes import Class, Method, URL, Body
from .utils import cached_property, extract_cookies

__version__ = "1.0.2"
__all__ = (
    "AutoRequests",
    "main",
    "__version__"
)


class AutoRequests:
    # filepath: Path
    # filename: str
    # file: File

    def __init__(self, *,
                 input_path: Path,
                 output_path: Path,
                 single_quote: bool = False,
                 return_text: bool = False,
                 no_headers: bool = False,
                 no_cookies: bool = False,
                 compare: bool = False,
                 parameters: bool = False
                 ):

        # params

        self.__single_quote = single_quote
        self.__return_text = return_text
        self.__no_headers = no_headers
        self.__no_cookies = no_cookies
        self.__compare = compare
        self.__parameters = parameters

        # dynamic
        self.__input_path: Path = input_path
        self.__output_path: Path = output_path
        self.__input_files: Dict[Path, Method] = {}
        self.__methods: List[Method] = self.methods_from_path(self.input_path)
        self.__classes: List[Class] = [Class(name=name, output_path=output_path) for name in
                                       {method.class_name for method in self.methods}]

        for cls in self.classes:
            self.methods.extend(self.methods_from_path(cls.folder))

        for method in self.methods:
            cls = self.find_class(method.class_name)
            cls.add_method(method)

    def __repr__(self) -> str:
        return f"<{self.__class__.__name__} classes={self.classes!r}>"

    @property
    def single_quote(self) -> bool:
        return self.__single_quote

    @property
    def return_text(self) -> bool:
        return self.__return_text

    @property
    def no_headers(self) -> bool:
        return self.__no_headers

    @property
    def no_cookies(self) -> bool:
        return self.__no_cookies

    @property
    def compare(self) -> bool:
        return self.__compare

    @property
    def parameters(self) -> bool:
        return self.__parameters

    @property
    def input_path(self) -> Path:
        return self.__input_path

    @property
    def output_path(self) -> Path:
        return self.__output_path

    @property
    def input_files(self):
        return self.__input_files

    @cached_property
    def methods(self) -> List[Method]:
        return self.__methods

    @cached_property
    def classes(self) -> List[Class]:
        return self.__classes

    def class_output_path(self, cls: Class):
        if self.output_path.name != cls.name:
            return self.output_path / cls.name

        return cls

    def methods_from_path(self, path: Path) -> List[Method]:
        methods = []
        for file in self.files_from_path(path):
            text = file.read_text(encoding="utf8", errors="ignore")
            method = self.method(text)
            if method is None:
                continue
            methods.append(method)
            self.input_files[file] = method
        return methods

    @property
    def top(self):
        return ("import requests\n"
                "\n"
                "\n"
                "# Automatically generated by https://github.com/Hexiro/autorequests.\n"
                "\n")

    def write(self):
        for cls in self.classes:
            if not cls.folder.exists():
                cls.folder.mkdir()
            main_py = cls.folder / "main.py"
            code = self.top + cls.code
            main_py.write_text(data=code, encoding="utf8", errors="strict")
        for file, method in self.input_files.items():
            class_name = method.class_name
            if self.output_path.name != class_name:
                file.rename(self.output_path / class_name / file.name)

    @staticmethod
    def files_from_path(path: Path) -> Generator[Path, None, None]:
        return path.glob("*.txt")

    def find_class(self, name: str) -> Optional[Class]:
        return next((cls for cls in self.classes if cls.name == name), None)

    @classmethod
    def method(cls, text: str) -> Optional[Method]:
        # short circuiting
        if text:
            return cls.method_from_fetch(text) or cls.method_from_powershell(text)

    @staticmethod
    def method_from_fetch(text: str) -> Optional[Method]:
        """
        Parses a file that follows this format:
        (with some being optional)

        fetch(<URL>, {
          "headers": <HEADERS>,
          "referrer": <REFERRER>,
          "referrerPolicy": <REFERRER-POLICY>,
          "body": <BODY>,
          "method": <METHOD>,
          "mode": <MODE>
        });
        """
        fetch = regexp.fetch_regexp.search(text)
        if not fetch:
            return

        headers = json.loads(fetch["headers"])
        # referer is spelled wrong in the HTTP header
        # referrer policy is not
        referrer = fetch["referrer"]
        referrer_policy = fetch["referrer_policy"]
        if referrer:
            headers["referer"] = referrer
        if referrer_policy:
            headers["referrer-policy"] = referrer_policy

        cookies = extract_cookies(headers)

        method = fetch["method"]
        url = URL(fetch["url"])
        body = Body(fetch["body"])

        return Method(method=method,
                      url=url,
                      body=body,
                      headers=headers,
                      cookies=cookies,
                      )

    @staticmethod
    def method_from_powershell(text: str) -> Optional[Method]:
        """
        Parses a file that follows this format:
        (with some potentially being optional)

        Invoke-WebRequest -Uri <URL> `
        -Method <METHOD> `   # optional; defaults to GET if not set
        -Headers <HEADERS> `
        -ContentType <CONTENT-TYPE> `   # optional; only exists w/ body
        -Body <BODY>     # optional; only exists if a body is present
        """
        powershell = regexp.powershell_regexp.search(text)
        if not powershell:
            return

        headers = {}
        for header in powershell["headers"].splitlines():
            if "=" in header:
                header = header.lstrip("  ")
                key, value = header.split("=", maxsplit=1)
                # remove leading and trailing "s that always exist
                key = key[1:-1]
                value = value[1:-1]
                headers[key] = value

        cookies = extract_cookies(headers)

        # ` is the escape character in powershell
        # replace two `s with a singular `
        # replace singular `s with nothing

        raw_body = powershell["body"]
        if raw_body:
            raw_body = raw_body.split("`")
            raw_body = "".join((e if e != "" else "`") for e in raw_body)

        method = powershell["method"] or "GET"
        url = URL(powershell["url"])
        body = Body(raw_body)

        return Method(method=method,
                      url=url,
                      body=body,
                      headers=headers,
                      cookies=cookies,
                      )

    # dynamic

    def main(self):
        self.write()
        self.print_results()

    def print_results(self):
        if len(self.classes) == 0:
            print("No request data could be located.")
            return
        num_classes = len(self.classes)
        num_methods = len(self.input_files)
        classes_noun = "classes" if num_classes > 1 else "class"
        methods_noun = "methods" if num_methods > 1 else "method"
        print(f"Successfully wrote {num_classes} {classes_noun} with a total of {num_methods} {methods_noun}.")


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-i", "--input", default=None, help="Input Directory")
    parser.add_argument("-o", "--output", default=None, help="Output Directory")
    parser.add_argument("-v", "--version", action="store_true")
    parser.add_argument("--return-text",
                        action="store_true",
                        help="Makes the generated method's responses return .text instead of .json()"
                        )
    parser.add_argument("--single-quote", action="store_true", help="Uses single quotes instead of double quotes")
    parser.add_argument("--no-headers", action="store_true", help="Removes all headers from the operation")
    parser.add_argument("--no-cookies", action="store_true", help="Removes all cookies from the operation")
    parser.add_argument("--compare", action="store_true",
                        help="Compares the previously generated files to the new files."
                        )
    parser.add_argument("--parameters",
                        action="store_true",
                        help="Replaces hardcoded params, json, data, etc with parameters that have default values")
    args = parser.parse_args()

    if not args:
        parser.print_help()
        return
    if args.version:
        print(f"AutoRequests {__version__}")
        return

    input_path = (Path(args.input) if args.input else Path.cwd()).resolve()
    output_path = (Path(args.output) if args.output else Path.cwd()).resolve()

    auto_requests = AutoRequests(
        input_path=input_path,
        output_path=output_path,
        single_quote=args.single_quote,
        return_text=args.return_text,
        no_headers=args.no_headers,
        no_cookies=args.no_cookies,
        compare=args.compare,
        parameters=args.parameters
    )
    auto_requests.main()


if __name__ == "__main__":
    main()
